# 앞서는 요인적재계수의 개념과 공분산의 성질을 알아보았고 이를 EFA라고 부름
# SEM의 맥락에서 도출된 것이다.
# EFA는 공통분산요소에 기반으로 공분산 구조를 모델링하는 반면
# SEM은 변수들 간의 수 많은 명시적 관계들을 모델링 하는 것을 목적으로 함
# SEM은 관측변수와 잠재변수를 모두 포함해 모델링한다는 점에서 EFA와 비슷하지만,
# 반드시 잠재변수를 포함해야 하는 것은 아니라는 점에서 EFA와 다르다
# SEM에서는 관측변수 및 잠재변수들 사이의 관계가 일련의 경로로 표현된다.
# 변수들간의 상관관계가 경로계수를 통해 나타내어 진다.
# 또한 EFA와 다르게 잔차들 역시 상관관계를 갖는 것이 허용된다.

# SEM은 관측변수(모형추정을 위해 수집한 데이터), 
# 잠재변수(직접 관측은 불가능한데 이론적으로 존재하는 변수 관측변수와 잠재변수 사이 혹은 잠재변수들 간에 성깁할 것으로 생각되는 관계),
# 경로(변수 간에 성립하는 이론적 관계 경로는 원인변수로부터 출발해 결과변수로 향하는 인과성, 혹은 방향성 없는 단순 연관 나타냄),
# 전차( 모형 경로를 통해 설명되지 않는 데이터의 부분),
# 공분산공식( 공분산 공식)

# SEM은 경로 그림을 작성하는 것이 중요하다. 관측변수는 직사각형 잠재변수는 타원형 상자, 경로계수는 화살표, 잔차 및 상관관계는 곡선으로 된 양방향 화살표로 나타냄
# SEM을 행렬로 표현하는 모형은 LISREL 모형 또는 단순 망상행동모형이다.
# 망상행동모형
# 모든 SEM에서는 내재공분산행렬을 구하는 것을 목표로 한다.
# 선형대수학적 표현은 모형의 계수 행렬들을 이용해 내재공분산행렬을 나타내기 위한 것.
# 이를 3가지 행렬로 설명한다.
# A = 경로계수로 구성된 비대칭 정방행렬, 행렬의 행의 개수는 모형에 포함된 변수의 갯수
# 모형에서 인과성을 나타내는 계수가 해당 변수의 행과 열의 위치에 놓여진다.
# S = 변수들 간 공분산 또는 잔차분산으로 구성된 대칭행렬, 행렬 A와 크기가 같다
# 대각원소는 잔차분산으로 채워져 있다. 인과관계만으로 설명이 안되는 공분산 관계가 남은 경우
# 잔차공분산 값으로 비대각원소를 채운다. 대각의 잔차분산항들은 잔차공분산의 특별한 경우로 생각한다
# 공분산의 대칭적 성질 때문에 원소의 값과 원소의 값이 같은 대칭행렬이 된다.
# F = 관측변수를 필터링 하는 행렬로, 단위행렬을 변형한 형태
# 행렬의 행의 개수는 모형에 포함된 모든 변수의 갯수와 같다.
# 관측 변수에 해당하는 행과 열에 1이 있게 되고 다른 곳은 0
# 따라서 각 관측변수에 대응되는 행과 열에 반드시 하나의 1을 갖게 된다.

# RAM 망상행동모형은 측정모형과 구조모형을 분리하고 있지 않음에 유의해야 한다. 필터링행렬과
# 경로계수행렬을 적당히 조합하면 측정모형과 구조모형을 구분하는 것은 가능하지만 어려운 일
# LISREL 행렬 표현에서는 대신에 몇 개의 추가적인 행렬을 사용해 측정모형과 구조모형을 분리

# 그리고 RAM은 분산 및 공분산을 명시적으로 모델링하기 때문에 EFA에서 가능하지 않던
# 것들이 가능하다는 것이 특징이다.
# 특정한 구조모형을 정의할 수 있게 해준다.
# 잠재변수들 사이에 상관관계에 대해 유연한 구조를 가정할 수 있다.

library(lavaan)
data("PoliticalDemocracy")
# 공분산 행렬 생성
pd.cov <- cov(PoliticalDemocracy)

# 이 다음에 행렬 A,S,F,I를 만들어야 한다. 

mat.A <- matrix(
  c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,1.5,0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0.5,0.5,0
  ), nrow = 14, byrow = TRUE
)

mat.S <- matrix(
  c(2, 0, 0, 0,.5, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 7, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 5, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
    0, 1, 0, 3, 0, 0, 0,.5, 0, 0, 0, 0, 0, 0,
    .5, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 2, 0, 0, 0, 5, 0, 1, 0, 0, 0, 0, 0, 0,
    0, 0, 1, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0,.5, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,.1, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,.1, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,.5, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,.5, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,.2
  ), nrow = 14, byrow = TRUE
)
mat.F <- matrix(
  c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0
  ), nrow = 11, byrow = TRUE
)
# 총 행렬 사이즈 A 14X14 S 14X14 F 11X14
# 마지막 I 14X14
mat.I <- diag(rep(1,14),nrow=14)

RAM.implied.covariance <- function (A.0,S.0,F.0,I.0)
{
  implied.covariance <- F.0 %*% solve(I.0-A.0) %*% S.0 %*% t(solve(I.0-A.0)) %*% t(F.0)
  return (implied.covariance)
}
# A와 S의 초기치 행렬을 사용해 내재공분산행렬을 추정
round(RAM.implied.covariance(mat.A,mat.S,mat.F,mat.I),2)
# 이와 이전에 생성한 공분산 행렬을 비교
round(pd.cov,2)
# 이 두 행렬이 어느정도 비슷하긴 한대, 더 비슷하게 하려면 A와S를 새로운 값으로 바꾸어가며 반복적인 알고리즘을 실행하면 가능
# SEM에서 해가 부정인 경우가 있으며, 이런 경우 제약 조건을 추가할 필요가 있다.
# 특정 경로계수에 대한 제약식을 생각 할 수 있다. 즉 어떤 잠재변수에서 지표변수로 가는 경로값에 대해 제약조건을 얹는 방식이다

#앞에서 봤듯이 좋은 해를 찼으려면 내재공분산행렬과 관측공분산행렬이 가까워야 하고,
# 이 방법은 반복알고리즘이 필요하다는 것이다.
# 가능한 한 가까운이라는 의미는 무엇인가?
# 이를 추정하는 방법은 세가지다 최소제곱법, 일반화체소제곱법, 최대우도방법
# 그 외에도 여러 방법이 있지만, 최소제곱법이 가장 간단하고 부담이 적다

# 마지막 단계는 적합된 모형이 데이터를 얼마나 잘 설명하는지, 적합도를 확인하는 것
# 적합도 측도는 카이제곱 분포에 기초한다. 이때 자유도는 추정된 모수의 개수와 알려진 공분산 값의 개수 간의 차이가 된다.
# 통상적인 검정법의 원리에 따라 카이제곱통계량 값이 임게치에 초과하면, 귀무가설을 기각하게 된다.
# 귀무가설의 기각은 실험 목적을 뒷받침하는 결과이다.
# SEM은 그 반대인데 귀무가설이 '모형이 데이터에 잘 적합된다'이기 때문이다.
# 유의하지 않은 카이제곱 값은 모형의 적합도를 뒷받침하는 결과이고, 반대로 유의한 카이제곱 값은
# 모형의 적합도를 기각하게 만드는 결과이다.
# 그러나 표본의 크기가 커지게 되면 카이제곱값이 증가하는 경향이 있어 적합도를 기각하는 검정력이 커짐
# 보통의 카이제곱 검정은 소표본에 기초한 모형은 채택하면서 대표본에 기초한 모형은 기각하는 경향이 있다.
# SEM에서도 적합도 측도의 선택과 해석은 논란의 대상.
# 카이제곱 검정통계량은 한계점을 가지고 있다.
# 그래서 나온 것은 CFI , RMSEA, TLI, SRMR 등이 있다.

source('http://openmx.psyc.virginia.edu/getOpenMx.R')

F <- FALSE
T <- TRUE

mx.A <- mxMatrix(
  type = "Full",
  nrow=14,
  ncol=14,
  values = c(
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0
  ),
  free = c(
    F, F, F, F, F, F, F, F, F, F, F, F, F, F,
    F, F, F, F, F, F, F, F, F, F, F, F, T, F,
    F, F, F, F, F, F, F, F, F, F, F, F, T, F,
    F, F, F, F, F, F, F, F, F, F, F, F, T, F,
    F, F, F, F, F, F, F, F, F, F, F, F, F, F,
    F, F, F, F, F, F, F, F, F, F, F, F, F, T,
    F, F, F, F, F, F, F, F, F, F, F, F, F, T,
    F, F, F, F, F, F, F, F, F, F, F, F, F, T,
    F, F, F, F, F, F, F, F, F, F, F, F, F, F,
    F, F, F, F, F, F, F, F, F, F, F, T, F, F,
    F, F, F, F, F, F, F, F, F, F, F, T, F, F,
    F, F, F, F, F, F, F, F, F, F, F, F, F, F,
    F, F, F, F, F, F, F, F, F, F, F, T, F, F,
    F, F, F, F, F, F, F, F, F, F, F, T, T, F
  ),
  byrow=TRUE,
  name="A",
)

# S1와 S2를 생성하는데 두 행렬은 단순히 초기치만 다르게 지정
# 하나의 행렬을 SEM에 적합시키게 하고, 문제점을 다른 하나로 해결 할 것이다
# 초기치를 1로 사용하고 하나는 5로 사용한다.
# 행렬 타입으로 "full"로 지정할 수 있지만 "symm"을 사용했기 때문에 상삼가가에 있는 원소를 입력하는 수고는 덜 수 있다.

mx.S1 <- mxMatrix("Symm", nrow=14, ncol=14,
                  values = c(
                    1,
                    0, 1,
                    0, 0, 1,
                    0, 1, 0, 1,
                    1, 0, 0, 0, 1,
                    0, 1, 0, 0, 0, 1,
                    0, 0, 1, 0, 0, 0, 1,
                    0, 0, 0, 1, 0, 1, 0, 1,
                    0, 0, 0, 0, 0, 0, 0, 0, 1,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1
                  ),
                  free = c(
                    T,
                    F, T,
                    F, F, T,
                    F, T, F, T,
                    T, F, F, F, T,
                    F, T, F, F, F, T,
                    F, F, T, F, F, F, T,
                    F, F, F, T, F, T, F, T,
                    F, F, F, F, F, F, F, F, T,
                    F, F, F, F, F, F, F, F, F, T,
                    F, F, F, F, F, F, F, F, F, F, T,
                    F, F, F, F, F, F, F, F, F, F, F, T,
                    F, F, F, F, F, F, F, F, F, F, F, F, T,
                    F, F, F, F, F, F, F, F, F, F, F, F, F, T
                  ),
                  byrow=TRUE,
                  name="S"
)

mx.S2 <- mxMatrix("Symm", nrow=14, ncol=14,
                  values = c(
                    5,
                    0, 5,
                    0, 0, 5,
                    0, 1, 0, 5,
                    1, 0, 0, 0, 5,
                    0, 1, 0, 0, 0, 5,
                    0, 0, 1, 0, 0, 0, 5,
                    0, 0, 0, 1, 0, 1, 0, 5,
                    0, 0, 0, 0, 0, 0, 0, 0, 5,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 5,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5
                  ),
                  free = c(
                    T,
                    F, T,
                    F, F, T,
                    F, T, F, T,
                    T, F, F, F, T,
                    F, T, F, F, F, T,
                    F, F, T, F, F, F, T,
                    F, F, F, T, F, T, F, T,
                    F, F, F, F, F, F, F, F, T,
                    F, F, F, F, F, F, F, F, F, T,
                    F, F, F, F, F, F, F, F, F, F, T,
                    F, F, F, F, F, F, F, F, F, F, F, T,
                    F, F, F, F, F, F, F, F, F, F, F, F, T,
                    F, F, F, F, F, F, F, F, F, F, F, F, F, T
                  ),
                  byrow=TRUE,
                  name="S"
)
# 단위행렬과 필터링행렬을 같은 방법으로 생성

mx.Filter <- mxMatrix("Full", nrow=11, ncol=14,
                      values= c(
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0
                      ),
                      free=FALSE,
                      name="Filter",
                      byrow = TRUE
)

mx.I <- mxMatrix("Full", nrow=14, ncol=14,
                 values= c(
                   1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                   0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                   0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                   0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                   0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                   0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                   0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                   0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
                   0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
                   0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
                   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1
                 ),
                 free=FALSE,
                 byrow = TRUE,
                 name="I"
)

# mxModel() 함수를 사용해 적합시킬 모형을 선언
# 우선 어느 행렬을 사용할지 지정
# 행렬들을 내재공분산행렬을 만들기 위해 어떻게 결합해야 하는지 지정
# mxMLObjective()함수를 사용해 추정밥법을 ML방법으로 지정하고 
# 공식을 지정한다.

factorModel.1 <- mxModel("Political Democracy Model",
                         #Model Matrices
                         mx.A,
                         mx.S1,
                         mx.Filter,
                         mx.I,
                         #Model Fitting Instructions
                         mxAlgebra(Filter %*% solve(I-A) %*% S %*% t(solve(I - A)) %*% t(Filter), name="C"),
                         mxMLObjective("C", dimnames = names(PoliticalDemocracy)),
                         #Data to fit
                         mxData(cov(PoliticalDemocracy), type="cov", numObs=75)
)

summary(mxRun(factorModel.1))

# 공분산 행렬의 기대값이 양정치행렬이 아니라는 에러메시지가 나왔다.
# 관측 공분산행렬은 양정치 행렬이지만 내재공분산 행렬은 아니다
# 이 문제는 초기값 행렬을 수정하는 것으로 해결된다. S의 초기값 행렬의 대각을 5로 지정하면 내재공분산 행렬이 양정치성질을
가질 수 있게 된다.

factorModel.2 <- mxModel("Political Democracy Model",
                         #Model Matrices
                         mx.A,
                         mx.S2,
                         mx.Filter,
                         mx.I,
                         #Model Fitting Instructions
                         mxAlgebra(Filter %*% solve(I-A) %*% S %*% t(solve(I - A)) %*% t(Filter), name="C"),
                         mxMLObjective("C", dimnames = names(PoliticalDemocracy)),
                         #Data to fit
                         mxData(cov(PoliticalDemocracy), type="cov", numObs=75)
)

summary(mxRun(factorModel.2))

# 결과를 보면 A행렬의 10번행 12번열의 모수가 2.18
# 이는 A 행렬의 12번째 변수인 ind60으로부터 10번째 변수인 x2로 가는 경로에 해당하는 위치다.
# 즉 ind60에서 x2로 가는 경로계수가 2.18이다.
# 실행이 중지된 시점에도 여전히 수렴이 진행중이었음을 의미하고
# 나름 최적의 해를 구한 것이므로 신뢰할만 하다는 의미

